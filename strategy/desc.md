# Strategy Pattern

## 의도 

전략 패턴은 알고리즘들의 패밀리를 정의하고 각 패밀리를 별도의 클래스에 넣은 후 그들의 객체들을 상호교환할 수 있도록 하는 행동 디자인 패턴입니다. 

## 문제

어느 날 당신은 여행자들을 위한 네비 앱을 만들기로 했습니다. 사용자가 주소를 입력하면 지도에 표시된 해당 목적지로 가는 가장 빠른 경로를 볼 수 있는 기능이었죠.

앱의 첫 번째 버전에서는 도로로 된 경로만을 만들 수 있었습니다. 차를 타고 여행하는 사람들은 만족했으나 모든 사용자가 여가 중에 운전하는 것을 좋아하지는 않았습니다.
그래서 그 다음 업데이트에서는 도보 경로를 만드는 기능을 추가했습니다. 바로 그 다음에는 사람들이 대중교통을 이용한 경로를 이용할 수 있도록 기능을 추가했습니다.

하지만 이후 자전거를 타는 사람들을 위한 경로를 만들 계획을 세웠고 심지어 그 다음에는 도시의 모든 관광 명소를 지나는 경로를 만들 수 있는 또 다른 옵션을 추가할 계획을 세웠습니다.

<img width="660" height="300" alt="image" src="https://github.com/user-attachments/assets/54b35bba-b8b3-4199-a4ad-b1016320b6c5" />

> 네비게이터의 코드가 복잡해졌습니다..

사업적인 측면에서 앱은 성공했지만, 기술적인 문제들이 많은 골칫거리를 야기했습니다. 새 경로 구축 알고리즘을 추가할 때마다 네비게이터의 메인 클래스의 크기가 두 배로
늘어났으며, 어느 시점이 되자 네비 앱은 유지하기가 너무 어려워졌습니다. 

간단한 버그를 수정하거나 주행거리 점수를 살짝 조정하기 위해 알고리즘 중 하나를 변경하면 전체 클래스에 영향이 미쳐 이미 작동하는 코드에서 조차 오류가 발생할 가능성이 높아졌습니다.

또한 팀워크가 비효율적이 되었습니다. 앱 출시 직후 고용된 팀원들은 병합 충돌을 해결하는데 너무 많은 시간을 할애해야 한다고 불평했습니다. 또 새로운 기능을 구현하려면
거대한 동일 클래스를 변경해야 했는데 이렇게 바꾼 내용들이 다른 팀원들이 생성한 코드와 충돌하곤 했습니다. 

- 기능 추가시 발생할 수 있는 문제
1. 소스코드의 비대 
2. 유지보수 힘듬  
3. 팀워크 저하

## 해결책

전략 패턴은 특정 작업을 다양한 방식으로 수행하는 클래스를 선택한 후 모든 알고리즘을 `strategies`이라는 별도의 클래스들로 추출할 것을 제안합니다. 

context라는 원래 클래스에는 전략 중 하나에 대한 참조를 저장하기 위한 필드가 있어야 합니다. 컨텍스트 작업을 자체적으로 실행하는 대신 연결된 전략 객체에 위임합니다. 

컨텍스트는 작업에 적합한 알고리즘을 선택할 책임이 없습니다. 대신 클라이언트가 원하는 전략을 컨텍스트에 전달합니다. 
사실 컨텍스트는 전략들에 대해 많이 알지 못합니다. 컨텍스트는 같은 일반 인터페이스를 통해 모든 전략과 함께 작동하며, 이 일반 인터페이스는 선택된 전략 내에 캡슐화된 

